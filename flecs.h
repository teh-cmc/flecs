#define flecs_STATIC

#ifndef FLECS_H
#define FLECS_H

// #define FLECS_LEGACY         /* Define for C89 support */
// #define FLECS_CUSTOM_BUILD   /* Define for customizing a build */
// #define FLECS_THREADING      /* Define for building with threading support */

/**
 * @file api_defines.h
 * @brief Supporting defines for the public API.
 *
 * This file contains constants / macro's that are typically not used by an
 * application but support the public API, and therefore must be exposed. This
 * header should not be included by itself.
 */

#ifndef FLECS_API_DEFINES_H
#define FLECS_API_DEFINES_H

/* Standard library dependencies */
#include <time.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

/* Non-standard but required. If not provided by platform, add manually. */
#include <stdint.h>

/* Contains macro's for importing / exporting symbols */
/*
                                   )
                                  (.)
                                  .|.
                                  | |
                              _.--| |--._
                           .-';  ;`-'& ; `&.
                          \   &  ;    &   &_/
                           |"""---...---"""|
                           \ | | | | | | | /
                            `---.|.|.|.---'

 * This file is generated by bake.lang.c for your convenience. Headers of
 * dependencies will automatically show up in this file. Include bake_config.h
 * in your main project file. Do not edit! */

#ifndef FLECS_BAKE_CONFIG_H
#define FLECS_BAKE_CONFIG_H

/* Headers of public dependencies */
/* No dependencies */

/* Convenience macro for exporting symbols */
#ifndef flecs_STATIC
#if flecs_EXPORTS && (defined(_MSC_VER) || defined(__MINGW32__))
  #define FLECS_API __declspec(dllexport)
#elif flecs_EXPORTS
  #define FLECS_API __attribute__((__visibility__("default")))
#elif defined _MSC_VER
  #define FLECS_API __declspec(dllimport)
#else
  #define FLECS_API
#endif
#else
  #define FLECS_API
#endif

#endif


#ifndef NDEBUG
#define FLECS_DBG_API FLECS_API
#else
#define FLECS_DBG_API
#endif

#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Language support defines
////////////////////////////////////////////////////////////////////////////////

#ifndef FLECS_LEGACY
#include <stdbool.h>
#endif

/* The API uses the native bool type in C++, or a custom one in C */
#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

typedef uint32_t ecs_flags32_t;
typedef uint64_t ecs_flags64_t;

/* Keep unsigned integers out of the codebase as they do more harm than good */
typedef int32_t ecs_size_t;

/** This reserves entity ids for components. Regular entity ids will start after
 * this constant. This affects performance of table traversal, as edges with ids 
 * lower than this constant are looked up in an array, whereas constants higher
 * than this id are looked up in a map. Increasing this value can improve
 * performance at the cost of (significantly) higher memory usage. */
#define ECS_HI_COMPONENT_ID (256) /* Maximum number of components */


////////////////////////////////////////////////////////////////////////////////
//// Reserved ids
////////////////////////////////////////////////////////////////////////////////

/* Builtin component ids */
#define FLECS__EEcsType (1)
#define FLECS__EEcsName (2)

/* Builtin tag ids */
#define EcsModule (ECS_HI_COMPONENT_ID + 0)
#define EcsDisabled (ECS_HI_COMPONENT_ID + 1)
#define EcsWildcard (ECS_HI_COMPONENT_ID + 2)

/* Builtin roles */
#define EcsScope (ECS_HI_COMPONENT_ID + 3)

/* Builtin module ids */
#define EcsFlecs (ECS_HI_COMPONENT_ID + 4)
#define EcsFlecsCore (ECS_HI_COMPONENT_ID + 5)

/* Value used to quickly check if component is builtin. This is used to quickly
 * filter out tables with builtin components (for example for ecs_delete) */
#define EcsLastInternalComponentId (ecs_typeid(EcsName))

/* The first user-defined component starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserComponentId (32)

/* The first user-defined entity starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserEntityId (ECS_HI_COMPONENT_ID + 32)


////////////////////////////////////////////////////////////////////////////////
//// Entity id macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_ENTITY_MASK       ((uint64_t)0xFFFFFFFF)
#define ECS_GENERATION_MASK   ((uint64_t)0xFFFF << 32)
#define ECS_GENERATION(e)     ((e & ECS_GENERATION_MASK) >> 32)
#define ECS_GENERATION_INC(e) ((e & ~ECS_GENERATION_MASK) | ((ECS_GENERATION(e) + 1) << 32))


////////////////////////////////////////////////////////////////////////////////
//// Entity id flags
////////////////////////////////////////////////////////////////////////////////

#define ECS_FLAGS             ((uint64_t)3 << 62)
#define ECS_PAIR              ((uint64_t)1 << 62)
#define ECS_TAG               ((uint64_t)2 << 62)


////////////////////////////////////////////////////////////////////////////////
//// Utilities for working with trait identifiers
////////////////////////////////////////////////////////////////////////////////

#define ecs_entity_t_lo(value) ((uint32_t)(value))
#define ecs_entity_t_hi(value) ((uint32_t)((value) >> 32))
#define ecs_entity_t_comb(v1, v2) (((uint64_t)(v2) << 32) + (uint32_t)(v1))


////////////////////////////////////////////////////////////////////////////////
//// Error codes
////////////////////////////////////////////////////////////////////////////////

#define ECS_INTERNAL_ERROR (1)
#define ECS_INVALID_OPERATION (2)
#define ECS_INVALID_PARAMETER (3)
#define ECS_INVALID_ID (4)
#define ECS_INVALID_COMPONENT (5)
#define ECS_OUT_OF_MEMORY (6)
#define ECS_MISSING_OS_API (7)
#define ECS_INCONSISTENT_COMPONENT_ACTION (8)
#define ECS_INVALID_FROM_WORKER (9)


////////////////////////////////////////////////////////////////////////////////
//// Utilities
////////////////////////////////////////////////////////////////////////////////

#define ECS_OFFSET(o, offset) (void*)(((uintptr_t)(o)) + ((uintptr_t)(offset)))
#define ECS_SIZEOF(T) (ecs_size_t)sizeof(T)
#define ECS_ALIGN(size, alignment) (ecs_size_t)((((((size_t)size) - 1) / ((size_t)alignment)) + 1) * ((size_t)alignment))
#define ECS_MAX(a, b) ((a > b) ? a : b)

/* Use alignof in C++, or a trick in C. */
#ifdef __cplusplus
#define ECS_ALIGNOF(T) (int64_t)alignof(T)
#elif defined(_MSC_VER)
#define ECS_ALIGNOF(T) (int64_t)__alignof(T)
#elif defined(__GNUC__)
#define ECS_ALIGNOF(T) (int64_t)__alignof__(T)
#else
#define ECS_ALIGNOF(T) ((int64_t)&((struct { char c; T d; } *)0)->d)
#endif

#if defined(__GNUC__)
#define ECS_UNUSED __attribute__((unused))
#else
#define ECS_UNUSED
#endif

#ifdef __cplusplus
}
#endif

#endif

typedef uint64_t ecs_entity_t;
typedef struct ecs_world_t ecs_world_t;

#ifndef FLECS_VECTOR_H
#define FLECS_VECTOR_H


typedef struct ecs_vector_t ecs_vector_t;

typedef int (*ecs_comparator_t)(
    const void* p1,
    const void *p2);

#ifdef __cplusplus
extern "C" {
#endif

FLECS_DBG_API ecs_vector_t* _ecs_vector_new(
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API ecs_vector_t* _ecs_vector_from_array(
    ecs_size_t elem_size,
    int32_t elem_count,
    void *array);

FLECS_DBG_API void ecs_vector_free(
    ecs_vector_t *vector);

FLECS_DBG_API void ecs_vector_clear(
    ecs_vector_t *vector);

FLECS_DBG_API void ecs_vector_assert_size(
    ecs_vector_t* vector_inout,
    ecs_size_t elem_size);  

FLECS_DBG_API void* _ecs_vector_add(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size);

FLECS_DBG_API void* _ecs_vector_addn(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API void* _ecs_vector_swap(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size);

FLECS_DBG_API void* _ecs_vector_get(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int32_t index);

FLECS_DBG_API void* _ecs_vector_last(
    const ecs_vector_t *vector,
    ecs_size_t elem_size);

FLECS_DBG_API int32_t _ecs_vector_set_min_size(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API int32_t _ecs_vector_set_min_count(
    ecs_vector_t **vector_inout,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API void ecs_vector_remove_last(
    ecs_vector_t *vector);

FLECS_DBG_API bool _ecs_vector_pop(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    void *value);

FLECS_DBG_API int32_t _ecs_vector_remove(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int32_t index);

FLECS_DBG_API void _ecs_vector_reclaim(
    ecs_vector_t **vector,
    ecs_size_t elem_size);

FLECS_DBG_API int32_t _ecs_vector_grow(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API int32_t _ecs_vector_set_size(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API int32_t _ecs_vector_set_count(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int32_t elem_count);

FLECS_DBG_API int32_t ecs_vector_count(
    const ecs_vector_t *vector);

FLECS_DBG_API int32_t ecs_vector_size(
    const ecs_vector_t *vector);

FLECS_DBG_API void* _ecs_vector_first(
    const ecs_vector_t *vector,
    ecs_size_t elem_size);

FLECS_DBG_API void _ecs_vector_sort(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    ecs_comparator_t compare_action);

FLECS_DBG_API void _ecs_vector_memory(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int32_t *allocd,
    int32_t *used);

FLECS_DBG_API ecs_vector_t* _ecs_vector_copy(
    const ecs_vector_t *src,
    ecs_size_t elem_size);


#define ecs_vector_new(T, elem_count) \
    _ecs_vector_new(ECS_SIZEOF(T), elem_count) 

#define ecs_vector_from_array(T, elem_count, array)\
    _ecs_vector_from_array(ECS_SIZEOF(T), elem_count, array)
    
#define ecs_vector_add(vector, T) \
    ((T*)_ecs_vector_add(vector, ECS_SIZEOF(T)))

#define ecs_vector_addn(vector, T, elem_count) \
    ((T*)_ecs_vector_addn(vector, ECS_SIZEOF(T), elem_count))

#define ecs_vector_swap(vector, T, elem_count) \
    ((T*)_ecs_vector_swap(vector, ECS_SIZEOF(T), elem_count))

#define ecs_vector_swap_t(vector, size, alignment, elem_count) \
    _ecs_vector_swap(vector, ECS_VECTOR_U(size, alignment), elem_count)

#define ecs_vector_get(vector, T, index) \
    ((T*)_ecs_vector_get(vector, ECS_SIZEOF(T), index))

#define ecs_vector_last(vector, T) \
    (T*)_ecs_vector_last(vector, ECS_SIZEOF(T))

#define ecs_vector_set_min_size(vector, T, size) \
    _ecs_vector_set_min_size(vector, ECS_SIZEOF(T), size)

#define ecs_vector_set_min_count(vector, T, size) \
    _ecs_vector_set_min_count(vector, ECS_SIZEOF(T), size)

#define ecs_vector_pop(vector, T, value) \
    _ecs_vector_pop(vector, ECS_SIZEOF(T), value)

#define ecs_vector_remove(vector, T, index) \
    _ecs_vector_remove(vector, ECS_SIZEOF(T), index)

#define ecs_vector_reclaim(vector, T)\
    _ecs_vector_reclaim(vector, ECS_SIZEOF(T))

#define ecs_vector_grow(vector, T, size) \
    _ecs_vector_grow(vector, ECS_SIZEOF(T), size)

#define ecs_vector_set_size(vector, T, elem_count) \
    _ecs_vector_set_size(vector, ECS_SIZEOF(T), elem_count)

#define ecs_vector_set_count(vector, T, elem_count) \
    _ecs_vector_set_count(vector, ECS_SIZEOF(T), elem_count)
    
#define ecs_vector_first(vector, T) \
    ((T*)_ecs_vector_first(vector, ECS_SIZEOF(T)))
    
#define ecs_vector_sort(vector, T, compare_action) \
    _ecs_vector_sort(vector, ECS_SIZEOF(T), compare_action)
    
#define ecs_vector_memory(vector, T, allocd, used) \
    _ecs_vector_memory(vector, ECS_SIZEOF(T), allocd, used)

#define ecs_vector_copy(src, T) \
    _ecs_vector_copy(src, ECS_SIZEOF(T))

#ifndef FLECS_LEGACY
#define ecs_vector_each(vector, T, var, ...)\
    {\
        int var##_i, var##_count = ecs_vector_count(vector);\
        T* var##_array = ecs_vector_first(vector, T);\
        for (var##_i = 0; var##_i < var##_count; var##_i ++) {\
            T* var = &var##_array[var##_i];\
            __VA_ARGS__\
        }\
    }
#endif

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_PAGED_H
#define FLECS_PAGED_H


typedef void* ecs_page_t;

typedef struct ecs_paged_t {
    ecs_vector_t *pages;
    ecs_size_t *column_sizes;
    int32_t column_count;
    int32_t count;
} ecs_paged_t;

#ifdef __cplusplus
extern "C" {
#endif

FLECS_DBG_API ecs_paged_t* ecs_paged_new(
    int32_t column_count,
    ecs_size_t *column_sizes);

FLECS_DBG_API void ecs_paged_init(
    ecs_paged_t *paged,
    int32_t column_count,
    ecs_size_t *column_sizes);

FLECS_DBG_API void ecs_paged_deinit(
    ecs_paged_t *paged);    

FLECS_DBG_API void ecs_paged_clear(
    ecs_paged_t *paged);

FLECS_DBG_API void ecs_paged_free(
    ecs_paged_t *paged);

FLECS_DBG_API void* _ecs_paged_get(
    const ecs_paged_t *paged,
    ecs_size_t size,
    int32_t index,
    int32_t column);

FLECS_DBG_API void* _ecs_paged_ensure(
    ecs_paged_t *paged,
    ecs_size_t size,
    int32_t index,
    int32_t column);

FLECS_DBG_API int32_t ecs_paged_add(
    ecs_paged_t *paged);

FLECS_DBG_API void ecs_paged_remove(
    ecs_paged_t *paged,
    int32_t index);

FLECS_DBG_API ecs_page_t* ecs_paged_get_page(
    const ecs_paged_t *paged,
    int32_t index);

FLECS_DBG_API ecs_page_t* ecs_paged_ensure_page(
    ecs_paged_t *paged,
    int32_t index);

FLECS_DBG_API void* _ecs_paged_page_get(
    const ecs_paged_t *paged,
    ecs_page_t *page, 
    ecs_size_t size,
    int32_t index,
    int32_t column);

FLECS_DBG_API int32_t ecs_paged_count(
    const ecs_paged_t *paged);

#define ecs_paged_get(paged, T, index, column)\
    ((T*)_ecs_paged_get(paged, ECS_SIZEOF(T), index, column))

#define ecs_paged_ensure(paged, T, index, column)\
    ((T*)_ecs_paged_ensure(paged, ECS_SIZEOF(T), index, column))

#define ecs_paged_page_get(paged, page, T, index, column)\
    ((T*)_ecs_paged_page_get(paged, page, ECS_SIZEOF(T), index, column))

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_SPARSE_H
#define FLECS_SPARSE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_sparse_t ecs_sparse_t;

FLECS_DBG_API ecs_sparse_t* _ecs_sparse_new(
    ecs_size_t elem_size);

FLECS_DBG_API void ecs_sparse_set_id_source(
    ecs_sparse_t *sparse,
    uint64_t *id_source);

FLECS_DBG_API void ecs_sparse_free(
    ecs_sparse_t *sparse);

FLECS_DBG_API void ecs_sparse_clear(
    ecs_sparse_t *sparse);

FLECS_DBG_API void* _ecs_sparse_add(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size);

FLECS_DBG_API uint64_t ecs_sparse_last_id(
    ecs_sparse_t *sparse);

FLECS_DBG_API uint64_t ecs_sparse_new_id(
    ecs_sparse_t *sparse);

FLECS_DBG_API const uint64_t* ecs_sparse_new_ids(
    ecs_sparse_t *sparse,
    int32_t count);

FLECS_DBG_API void ecs_sparse_remove(
    ecs_sparse_t *sparse,
    uint64_t id);

FLECS_DBG_API void* _ecs_sparse_remove_get(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t id);    

FLECS_DBG_API void ecs_sparse_set_generation(
    ecs_sparse_t *sparse,
    uint64_t id);    

FLECS_DBG_API bool ecs_sparse_exists(
    const ecs_sparse_t *sparse,
    uint64_t id);

FLECS_DBG_API void* _ecs_sparse_get_elem(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t elem);

FLECS_DBG_API bool ecs_sparse_is_alive(
    const ecs_sparse_t *sparse,
    uint64_t id);

FLECS_DBG_API int32_t ecs_sparse_count(
    const ecs_sparse_t *sparse);

FLECS_DBG_API int32_t ecs_sparse_size(
    const ecs_sparse_t *sparse);

FLECS_DBG_API void* _ecs_sparse_get(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t id);

FLECS_DBG_API void* _ecs_sparse_get_any(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t id);

FLECS_DBG_API void* _ecs_sparse_get_or_create(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t id);

FLECS_DBG_API const uint64_t* ecs_sparse_ids(
    const ecs_sparse_t *sparse);

FLECS_DBG_API void ecs_sparse_set_size(
    ecs_sparse_t *sparse,
    int32_t elem_count);

FLECS_DBG_API ecs_sparse_t* ecs_sparse_copy(
    const ecs_sparse_t *src);    

FLECS_DBG_API void ecs_sparse_restore(
    ecs_sparse_t *dst,
    const ecs_sparse_t *src);

FLECS_DBG_API void ecs_sparse_memory(
    const ecs_sparse_t *sparse,
    int32_t *allocd,
    int32_t *used);

#define ecs_sparse_new(type)\
    _ecs_sparse_new(sizeof(type))

#define ecs_sparse_add(sparse, type)\
    ((type*)_ecs_sparse_add(sparse, sizeof(type)))

#define ecs_sparse_remove_get(sparse, type, id)\
    ((type*)_ecs_sparse_remove_get(sparse, sizeof(type), id))

#define ecs_sparse_get_elem(sparse, type, id)\
    ((type*)_ecs_sparse_get_elem(sparse, sizeof(type), id))

#define ecs_sparse_get(sparse, type, id)\
    ((type*)_ecs_sparse_get(sparse, sizeof(type), id))

#define ecs_sparse_get_any(sparse, type, id)\
    ((type*)_ecs_sparse_get_any(sparse, sizeof(type), id))

#define ecs_sparse_ensure(sparse, type, id)\
    ((type*)_ecs_sparse_get_or_create(sparse, sizeof(type), id))

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_DENSE_H
#define FLECS_DENSE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    ecs_paged_t sparse;         /* Paged array with sparse payload */
    ecs_paged_t dense;
    // ecs_vector_t *dense;        /* Dense array with indices to sparse array. The
    //                              * dense array stores both alive and not alive
    //                              * sparse indices. The 'count' member keeps
    //                              * track of which indices are alive. */
    // ecs_vector_t *data;         /* Dense payload */
    int16_t size;
} ecs_dense_t;

FLECS_DBG_API void _ecs_dense_init(
    ecs_dense_t *dense,
    ecs_size_t size);

FLECS_DBG_API void ecs_dense_fini(
    ecs_dense_t *dense);

FLECS_DBG_API ecs_dense_t* _ecs_dense_new(
    ecs_size_t dense_size);

FLECS_DBG_API void ecs_dense_free(
    ecs_dense_t *dense);

FLECS_DBG_API void* _ecs_dense_get(
    const ecs_dense_t *dense,
    ecs_size_t size,
    uint64_t id);

FLECS_DBG_API bool _ecs_dense_ensure(
    ecs_dense_t *dense,
    ecs_size_t size,
    uint64_t id);

struct ecs_dense_ensure_get_t {
    void *ptr;
    bool added;
};

FLECS_DBG_API struct ecs_dense_ensure_get_t _ecs_dense_ensure_get(
    ecs_dense_t *dense,
    ecs_size_t size,
    uint64_t id); 

FLECS_DBG_API bool ecs_dense_remove(
    ecs_dense_t *dense,
    uint64_t id);

FLECS_DBG_API void ecs_dense_clear(
    ecs_dense_t *d);

FLECS_DBG_API int32_t ecs_dense_count(
    const ecs_dense_t *d);

FLECS_DBG_API int32_t ecs_dense_size(
    const ecs_dense_t *d);

#define ecs_dense_new(T)\
    _ecs_dense_new(sizeof(T))

#define ecs_dense_get(dense, T, id)\
    _ecs_dense_get(dense, sizeof(T), id)

#define ecs_dense_ensure(dense, T, id)\
    _ecs_dense_ensure(dense, sizeof(T), id)

#define ecs_dense_ensure_get(dense, T, id)\
    _ecs_dense_ensure_get(dense, sizeof(T), id)

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_PTREE_H
#define FLECS_PTREE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct addr_t {
    uint16_t value[4];
} addr_t;

typedef struct {
    void *data;
    uint16_t offset;
    int32_t length;
} array_t;

typedef struct {
    array_t data;
    array_t pages;
} page_t;

typedef struct {
    page_t root;
    void *first_65k;
    uint16_t min_65k;
    uint16_t max_65k;
    uint8_t elem_size;
} ecs_ptree_t;

typedef struct {
    ecs_ptree_t *ptree;
    void *frames[3];
    uint16_t cur_page[3];
    int32_t cur_elem;
    int8_t sp;
    uint64_t index;
} ecs_ptree_iter_t;

FLECS_DBG_API void _ecs_ptree_init(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size);

FLECS_DBG_API ecs_ptree_t* _ecs_ptree_new(
    ecs_size_t elem_size);

FLECS_DBG_API int32_t ecs_ptree_fini(
    ecs_ptree_t *ptree);

FLECS_DBG_API int32_t ecs_ptree_free(
    ecs_ptree_t *ptree);

FLECS_DBG_API void* _ecs_ptree_ensure(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

FLECS_DBG_API void* _ecs_ptree_get(
    const ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

FLECS_DBG_API ecs_ptree_iter_t ecs_ptree_iter(
    ecs_ptree_t *ptree);

FLECS_DBG_API ecs_ptree_iter_t ecs_ptiny_iter(
    ecs_ptree_t *ptree);

FLECS_DBG_API void* _ecs_ptree_next(
    ecs_ptree_iter_t *it,
    ecs_size_t elem_size);    

FLECS_DBG_API void* _ecs_ptiny_next(
    ecs_ptree_iter_t *it,
    ecs_size_t elem_size);

#define ecs_ptree_init(ptree, T)\
    _ecs_ptree_init(ptree, ECS_SIZEOF(T))

#define ecs_ptree_new(T)\
    _ecs_ptree_new(ECS_SIZEOF(T))

#define ecs_ptree_get(ptree, T, index)\
    (T*)_ecs_ptree_get(ptree, ECS_SIZEOF(T), index)

#define ecs_ptree_ensure(ptree, T, index)\
    _ecs_ptree_ensure(ptree, ECS_SIZEOF(T), index)

#define ecs_ptree_next(iter, T)\
    _ecs_ptree_next(iter, ECS_SIZEOF(T))


/* -- Low footprint version, do not mix new/get/ensure API calls -- */

FLECS_DBG_API ecs_ptree_t* _ecs_ptiny_new(
    ecs_size_t elem_size);

FLECS_DBG_API void _ecs_ptiny_init(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size);

FLECS_DBG_API void* _ecs_ptiny_ensure(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

FLECS_DBG_API void* _ecs_ptiny_get(
    const ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_ptiny_init(ptree, T)\
    _ecs_ptiny_init(ptree, ECS_SIZEOF(T))

#define ecs_ptiny_new(T)\
    _ecs_ptiny_new(ECS_SIZEOF(T))

#define ecs_ptiny_get(ptree, T, index)\
    (T*)_ecs_ptiny_get(ptree, ECS_SIZEOF(T), index)

#define ecs_ptiny_ensure(ptree, T, index)\
    _ecs_ptiny_ensure(ptree, ECS_SIZEOF(T), index)

#define ecs_ptiny_next(iter, T)\
    _ecs_ptiny_next(iter, ECS_SIZEOF(T))

#define ecs_ptiny_free(ptree)\
    ecs_ptree_free(ptree)

#ifdef __cplusplus
}
#endif

#endif
/** Key-value datastructure. The map allows for fast retrieval of a payload for
 * a 64-bit key. While it is not as fast as the sparse set, it is better at
 * handling randomly distributed values.
 *
 * Payload is stored in bucket arrays. A bucket is computed from an id by
 * using the (bucket_count - 1) as an AND-mask. The number of buckets is always
 * a power of 2. Multiple keys will be stored in the same bucket. As a result
 * the worst case retrieval performance of the map is O(n), though this is rare.
 * On average lookup performance should equal O(1).
 *
 * The datastructure will automatically grow the number of buckets when the
 * ratio between elements and buckets exceeds a certain threshold (LOAD_FACTOR).
 *
 * Note that while the implementation is a hashmap, it can only compute hashes
 * for the provided 64 bit keys. This means that the provided keys must always
 * be unique. If the provided keys are hashes themselves, it is the 
 * responsibility of the user to ensure that collisions are handled.
 *
 * In debug mode the map verifies that the type provided to the map functions
 * matches the one used at creation time.
 */

#ifndef FLECS_MAP_H
#define FLECS_MAP_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_map_t ecs_map_t;
typedef struct ecs_bucket_t ecs_bucket_t;
typedef uint64_t ecs_map_key_t;

typedef struct ecs_map_iter_t {
    const ecs_map_t *map;
    ecs_bucket_t *bucket;
    int32_t bucket_index;
    int32_t element_index;
    void *payload;
} ecs_map_iter_t;

/** Create new map. */
FLECS_DBG_API ecs_map_t * _ecs_map_new(
    ecs_size_t elem_size,
    ecs_size_t alignment, 
    int32_t elem_count);

#define ecs_map_new(T, elem_count)\
    _ecs_map_new(sizeof(T), ECS_ALIGNOF(T), elem_count)

/** Get element for key, returns NULL if they key doesn't exist. */
FLECS_DBG_API void * _ecs_map_get(
    const ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key);

#define ecs_map_get(map, T, key)\
    (T*)_ecs_map_get(map, sizeof(T), (ecs_map_key_t)key)

/** Get pointer element. This dereferences the map element as a pointer. This
 * operation returns NULL when either the element does not exist or whether the
 * pointer is NULL, and should therefore only be used when the application knows
 * for sure that a pointer should never be NULL. */
FLECS_DBG_API void * _ecs_map_get_ptr(
    const ecs_map_t *map,
    ecs_map_key_t key);

#define ecs_map_get_ptr(map, T, key)\
    (T)_ecs_map_get_ptr(map, key)

/** Get or create element for key. */
FLECS_DBG_API void * _ecs_map_ensure(
    ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key);

#define ecs_map_ensure(map, T, key)\
    (T*)_ecs_map_ensure(map, sizeof(T), (ecs_map_key_t)key)

/** Set element. */
FLECS_DBG_API void* _ecs_map_set(
    ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key,
    const void *payload);

#define ecs_map_set(map, key, payload)\
    _ecs_map_set(map, sizeof(*payload), (ecs_map_key_t)key, payload);

/** Free map. */
FLECS_DBG_API void ecs_map_free(
    ecs_map_t *map);

/** Remove key from map. */
FLECS_DBG_API void ecs_map_remove(
    ecs_map_t *map,
    ecs_map_key_t key);

/** Remove all elements from map. */
FLECS_DBG_API void ecs_map_clear(
    ecs_map_t *map);

/** Return number of elements in map. */
FLECS_DBG_API int32_t ecs_map_count(
    const ecs_map_t *map);

/** Return number of buckets in map. */
FLECS_DBG_API int32_t ecs_map_bucket_count(
    const ecs_map_t *map);

/** Return iterator to map contents. */
FLECS_DBG_API ecs_map_iter_t ecs_map_iter(
    const ecs_map_t *map);

/** Obtain next element in map from iterator. */
FLECS_DBG_API void* _ecs_map_next(
    ecs_map_iter_t* iter,
    ecs_size_t elem_size,
    ecs_map_key_t *key);

#define ecs_map_next(iter, T, key) \
    (T*)_ecs_map_next(iter, sizeof(T), key)

/** Obtain next pointer element from iterator. See ecs_map_get_ptr. */
FLECS_DBG_API void* _ecs_map_next_ptr(
    ecs_map_iter_t* iter,
    ecs_map_key_t *key);

#define ecs_map_next_ptr(iter, T, key) \
    (T)_ecs_map_next_ptr(iter, key)

/** Grow number of buckets in the map for specified number of elements. */
FLECS_DBG_API void ecs_map_grow(
    ecs_map_t *map, 
    int32_t elem_count);

/** Set number of buckets in the map for specified number of elements. */
FLECS_DBG_API void ecs_map_set_size(
    ecs_map_t *map, 
    int32_t elem_count);

/** Return memory occupied by map. */
FLECS_DBG_API void ecs_map_memory(
    ecs_map_t *map, 
    int32_t *allocd,
    int32_t *used);

#ifndef FLECS_LEGACY
#define ecs_map_each(map, T, key, var, ...)\
    {\
        ecs_map_iter_t it = ecs_map_iter(map);\
        ecs_map_key_t key;\
        T* var;\
        (void)key;\
        (void)var;\
        while ((var = ecs_map_next(&it, T, &key))) {\
            __VA_ARGS__\
        }\
    }
#endif
#ifdef __cplusplus
}
#endif

/** C++ wrapper for map. */
#ifdef __cplusplus
#ifndef FLECS_NO_CPP

#include <iostream>

namespace flecs {

template <typename K, typename T>
class map {
public:
    map(int32_t count = 0) { 
        init(count);
    }

    map(std::initializer_list<std::pair<K, T>> elems) {
        init(elems.size());
        *this = elems;
    }

    void operator=(std::initializer_list<std::pair<K, T>> elems) {
        for (auto elem : elems) {
            this->set(elem.first, elem.second);
        }
    }

    void clear() {
        ecs_map_clear(m_map);
    }

    int32_t count() {
        return ecs_map_count(m_map);
    }

    void set(K& key, T& value) {
        ecs_map_set(m_map, reinterpret_cast<ecs_map_key_t>(key), &value);
    }

    T& get(K& key) {
        *(T*)ecs_map_get(m_map, T, reinterpret_cast<ecs_map_key_t>(key));
    }

private:
    void init(int32_t count) {
        m_map = ecs_map_new(T, count);
    }

    ecs_map_t *m_map;
};

}

#endif
#endif

#endif
#ifndef FLECS_OS_API_H
#define FLECS_OS_API_H

#include <stdarg.h>

#if defined(_MSC_VER) || defined(__MINGW32__)
#include <malloc.h>
#elif defined(__FreeBSD__)
#include <stdlib.h>
#else
#include <alloca.h>
#endif

#if defined(_WIN32)
#define ECS_OS_WINDOWS
#elif defined(__linux__)
#define ECS_OS_LINUX
#elif defined(__APPLE__) && defined(__MACH__)
#define ECS_OS_DARWIN
#else
/* Unknown OS */
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_time_t {
    uint32_t sec;
    uint32_t nanosec;
} ecs_time_t;

/* Allocation counters (not thread safe) */
extern int64_t ecs_os_api_malloc_count;
extern int64_t ecs_os_api_realloc_count;
extern int64_t ecs_os_api_calloc_count;
extern int64_t ecs_os_api_free_count;

/* Use handle types that _at least_ can store pointers */
typedef uintptr_t ecs_os_thread_t;
typedef uintptr_t ecs_os_cond_t;
typedef uintptr_t ecs_os_mutex_t;
typedef uintptr_t ecs_os_dl_t;

/* Generic function pointer type */
typedef void (*ecs_os_proc_t)(void);

/* OS API init */
typedef 
void (*ecs_os_api_init_t)(void);

/* OS API deinit */
typedef 
void (*ecs_os_api_fini_t)(void);

/* Memory management */
typedef 
void* (*ecs_os_api_malloc_t)(
    ecs_size_t size);

typedef 
void (*ecs_os_api_free_t)(
    void *ptr);

typedef
void* (*ecs_os_api_realloc_t)(
    void *ptr, 
    ecs_size_t size);

typedef
void* (*ecs_os_api_calloc_t)(
    ecs_size_t size);

typedef
char* (*ecs_os_api_strdup_t)(
    const char *str);

/* Threads */
typedef
void* (*ecs_os_thread_callback_t)(
    void*);

typedef
ecs_os_thread_t (*ecs_os_api_thread_new_t)(
    ecs_os_thread_callback_t callback,
    void *param);

typedef
void* (*ecs_os_api_thread_join_t)(
    ecs_os_thread_t thread);


/* Atomic increment / decrement */
typedef
int (*ecs_os_api_ainc_t)(
    int32_t *value);


/* Mutex */
typedef
ecs_os_mutex_t (*ecs_os_api_mutex_new_t)(
    void);

typedef
void (*ecs_os_api_mutex_lock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_unlock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_free_t)(
    ecs_os_mutex_t mutex);

/* Condition variable */
typedef
ecs_os_cond_t (*ecs_os_api_cond_new_t)(
    void);

typedef
void (*ecs_os_api_cond_free_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_signal_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_broadcast_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_wait_t)(
    ecs_os_cond_t cond,
    ecs_os_mutex_t mutex);

typedef 
void (*ecs_os_api_sleep_t)(
    int32_t sec,
    int32_t nanosec);

typedef
void (*ecs_os_api_get_time_t)(
    ecs_time_t *time_out);

/* Logging */
typedef
void (*ecs_os_api_log_t)(
    const char *fmt,
    va_list args);

/* Application termination */
typedef
void (*ecs_os_api_abort_t)(
    void);

/* Dynamic libraries */
typedef
ecs_os_dl_t (*ecs_os_api_dlopen_t)(
    const char *libname);

typedef
ecs_os_proc_t (*ecs_os_api_dlproc_t)(
    ecs_os_dl_t lib,
    const char *procname);

typedef
void (*ecs_os_api_dlclose_t)(
    ecs_os_dl_t lib);

typedef
char* (*ecs_os_api_module_to_path_t)(
    const char *module_id);

/* Prefix members of struct with 'ecs_' as some system headers may define 
 * macro's for functions like "strdup", "log" or "_free" */

typedef struct ecs_os_api_t {
    /* API init / deinit */
    ecs_os_api_init_t init_;
    ecs_os_api_fini_t fini_;

    /* Memory management */
    ecs_os_api_malloc_t malloc_;
    ecs_os_api_realloc_t realloc_;
    ecs_os_api_calloc_t calloc_;
    ecs_os_api_free_t free_;

    /* Strings */
    ecs_os_api_strdup_t strdup_;

    /* Threads */
    ecs_os_api_thread_new_t thread_new_;
    ecs_os_api_thread_join_t thread_join_;

    /* Atomic incremenet / decrement */
    ecs_os_api_ainc_t ainc_;
    ecs_os_api_ainc_t adec_;

    /* Mutex */
    ecs_os_api_mutex_new_t mutex_new_;
    ecs_os_api_mutex_free_t mutex_free_;
    ecs_os_api_mutex_lock_t mutex_lock_;
    ecs_os_api_mutex_lock_t mutex_unlock_;

    /* Condition variable */
    ecs_os_api_cond_new_t cond_new_;
    ecs_os_api_cond_free_t cond_free_;
    ecs_os_api_cond_signal_t cond_signal_;
    ecs_os_api_cond_broadcast_t cond_broadcast_;
    ecs_os_api_cond_wait_t cond_wait_;

    /* Time */
    ecs_os_api_sleep_t sleep_;
    ecs_os_api_get_time_t get_time_;

    /* Logging */
    ecs_os_api_log_t log_;
    ecs_os_api_log_t log_error_;
    ecs_os_api_log_t log_debug_;
    ecs_os_api_log_t log_warning_;

    /* Application termination */
    ecs_os_api_abort_t abort_;

    /* Dynamic library loading */
    ecs_os_api_dlopen_t dlopen_;
    ecs_os_api_dlproc_t dlproc_;
    ecs_os_api_dlclose_t dlclose_;

    /* Overridable function that translates from a logical module id to a
     * shared library filename */
    ecs_os_api_module_to_path_t module_to_dl_;

    /* Overridable function that translates from a logical module id to a
     * path that contains module-specif resources or assets */
    ecs_os_api_module_to_path_t module_to_etc_;    
} ecs_os_api_t;

FLECS_API
extern ecs_os_api_t ecs_os_api;

FLECS_API
void ecs_os_init(void);

FLECS_API
void ecs_os_fini(void);

FLECS_API
void ecs_os_set_api(
    ecs_os_api_t *os_api);

FLECS_API
void ecs_os_set_api_defaults(void);

/* Memory management */
#define ecs_os_malloc(size) ecs_os_api.malloc_(size);
#define ecs_os_free(ptr) ecs_os_api.free_(ptr);
#define ecs_os_realloc(ptr, size) ecs_os_api.realloc_(ptr, size)
#define ecs_os_calloc(size) ecs_os_api.calloc_(size)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define ecs_os_alloca(size) _alloca((size_t)(size))
#else
#define ecs_os_alloca(size) alloca((size_t)(size))
#endif

/* Strings */
#define ecs_os_strdup(str) ecs_os_api.strdup_(str)
#define ecs_os_strlen(str) (ecs_size_t)strlen(str)
#define ecs_os_strcmp(str1, str2) strcmp(str1, str2)
#define ecs_os_strncmp(str1, str2, num) strncmp(str1, str2, (size_t)(num))
#define ecs_os_memcmp(ptr1, ptr2, num) memcmp(ptr1, ptr2, (size_t)(num))
#define ecs_os_memcpy(ptr1, ptr2, num) memcpy(ptr1, ptr2, (size_t)(num))
#define ecs_os_memset(ptr, value, num) memset(ptr, value, (size_t)(num))
#define ecs_os_memmove(ptr1, ptr2, num) memmove(ptr1, ptr2, (size_t)(num))

#if defined(_MSC_VER)
#define ecs_os_strcat(str1, str2) strcat_s(str1, INT_MAX, str2)
#define ecs_os_sprintf(ptr, ...) sprintf_s(ptr, INT_MAX, __VA_ARGS__)
#define ecs_os_vsprintf(ptr, fmt, args) vsprintf_s(ptr, INT_MAX, fmt, args)
#define ecs_os_strcpy(str1, str2) strcpy_s(str1, INT_MAX, str2)
#define ecs_os_strncpy(str1, str2, num) strncpy_s(str1, INT_MAX, str2, (size_t)(num))
#else
#define ecs_os_strcat(str1, str2) strcat(str1, str2)
#define ecs_os_sprintf(ptr, ...) sprintf(ptr, __VA_ARGS__)
#define ecs_os_vsprintf(ptr, fmt, args) vsprintf(ptr, fmt, args)
#define ecs_os_strcpy(str1, str2) strcpy(str1, str2)
#define ecs_os_strncpy(str1, str2, num) strncpy(str1, str2, (size_t)(num))
#endif


/* Threads */
#define ecs_os_thread_new(callback, param) ecs_os_api.thread_new_(callback, param)
#define ecs_os_thread_join(thread) ecs_os_api.thread_join_(thread)

/* Atomic increment / decrement */
#define ecs_os_ainc(value) ecs_os_api.ainc_(value)
#define ecs_os_adec(value) ecs_os_api.adec_(value)

/* Mutex */
#define ecs_os_mutex_new() ecs_os_api.mutex_new_()
#define ecs_os_mutex_free(mutex) ecs_os_api.mutex_free_(mutex)
#define ecs_os_mutex_lock(mutex) ecs_os_api.mutex_lock_(mutex)
#define ecs_os_mutex_unlock(mutex) ecs_os_api.mutex_unlock_(mutex)

/* Condition variable */
#define ecs_os_cond_new() ecs_os_api.cond_new_()
#define ecs_os_cond_free(cond) ecs_os_api.cond_free_(cond)
#define ecs_os_cond_signal(cond) ecs_os_api.cond_signal_(cond)
#define ecs_os_cond_broadcast(cond) ecs_os_api.cond_broadcast_(cond)
#define ecs_os_cond_wait(cond, mutex) ecs_os_api.cond_wait_(cond, mutex)

/* Time */
#define ecs_os_sleep(sec, nanosec) ecs_os_api.sleep_(sec, nanosec)
#define ecs_os_get_time(time_out) ecs_os_api.get_time_(time_out)

/* Logging (use functions to avoid using variadic macro arguments) */
FLECS_API
void ecs_os_log(const char *fmt, ...);

FLECS_API
void ecs_os_warn(const char *fmt, ...);

FLECS_API
void ecs_os_err(const char *fmt, ...);

FLECS_API
void ecs_os_dbg(const char *fmt, ...);

/* Application termination */
#define ecs_os_abort() ecs_os_api.abort_()

/* Dynamic libraries */
#define ecs_os_dlopen(libname) ecs_os_api.dlopen_(libname)
#define ecs_os_dlproc(lib, procname) ecs_os_api.dlproc_(lib, procname)
#define ecs_os_dlclose(lib) ecs_os_api.dlclose_(lib)

/* Module id translation */
#define ecs_os_module_to_dl(lib) ecs_os_api.module_to_dl_(lib)
#define ecs_os_module_to_etc(lib) ecs_os_api.module_to_etc_(lib)

/* Sleep with floating point time */
FLECS_API void ecs_sleepf(
    double t);

FLECS_API void ecs_os_gettime(
    ecs_time_t *time);

/* Measure time since provided timestamp */
FLECS_API double ecs_time_measure(
    ecs_time_t *start);

/* Calculate difference between two timestamps */
FLECS_API ecs_time_t ecs_time_sub(
    ecs_time_t t1,
    ecs_time_t t2);

/* Convert time value to a double */
FLECS_API double ecs_time_to_double(
    ecs_time_t t);

FLECS_API void* ecs_os_memdup(
    const void *src, 
    ecs_size_t size);

/** Are heap functions available? */
FLECS_API bool ecs_os_has_heap(void);

/** Are threading functions available? */
FLECS_API bool ecs_os_has_threading(void);

/** Are time functions available? */
FLECS_API bool ecs_os_has_time(void);

/** Are logging functions available? */
FLECS_API bool ecs_os_has_logging(void);

/** Are dynamic library functions available? */
FLECS_API bool ecs_os_has_dl(void);

/** Are module path functions available? */
FLECS_API bool ecs_os_has_modules(void);

#ifdef __cplusplus
}
#endif

#endif
/**
 * @file api_defines.h
 * @brief Supporting types for the public API.
 *
 * This file containstypes that are typically not used by an application but 
 * support the public API, and therefore must be exposed. This header should not
 * be included by itself.
 */

#ifndef FLECS_API_TYPES_H
#define FLECS_API_TYPES_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_table_t ecs_table_t;


////////////////////////////////////////////////////////////////////////////////
//// Non-opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_record_t {
    ecs_table_t *table;  /* Identifies a type (and table) in world */
    int32_t row;         /* Table row of the entity */
} ecs_record_t;

/** Array of entity ids that, other than a type, can live on the stack */
typedef struct ecs_entities_t {
    ecs_entity_t *array;    /**< An array with entity ids */
    int32_t count;          /**< The number of entities in the array */
} ecs_entities_t;

typedef struct ecs_world_info_t {
    ecs_entity_t last_component_id;   /**< Last issued component entity id */
    ecs_entity_t last_id;             /**< Last issued entity id */
} ecs_world_info_t;


////////////////////////////////////////////////////////////////////////////////
//// Function types
////////////////////////////////////////////////////////////////////////////////

/** Constructor/destructor. Used for initializing / deinitializing components. */
typedef void (*ecs_xtor_t)(
    void *ptr,
    size_t size,
    int32_t count);

/** Copy is invoked when a component is copied into another component. */
typedef void (*ecs_copy_t)(
    void *dst_ptr,
    const void *src_ptr,
    size_t size,
    int32_t count);

/** Move is invoked when a component is moved to another component. */
typedef void (*ecs_move_t)(
    void *dst_ptr,
    void *src_ptr,
    size_t size,
    int32_t count);

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_LOG_H
#define FLECS_LOG_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Color macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_BLACK   "\033[1;30m"
#define ECS_RED     "\033[0;31m"
#define ECS_GREEN   "\033[0;32m"
#define ECS_YELLOW  "\033[0;33m"
#define ECS_BLUE    "\033[0;34m"
#define ECS_MAGENTA "\033[0;35m"
#define ECS_CYAN    "\033[0;36m"
#define ECS_WHITE   "\033[1;37m"
#define ECS_GREY    "\033[0;37m"
#define ECS_NORMAL  "\033[0;49m"
#define ECS_BOLD    "\033[1;49m"


////////////////////////////////////////////////////////////////////////////////
//// Tracing
////////////////////////////////////////////////////////////////////////////////

FLECS_API void _ecs_trace(
    int level,
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void _ecs_warn(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void _ecs_err(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void ecs_log_push(void);

FLECS_API void ecs_log_pop(void);

#ifndef FLECS_LEGACY

#define ecs_trace(lvl, ...)\
    _ecs_trace(lvl, __FILE__, __LINE__, __VA_ARGS__)

#define ecs_warn(...)\
    _ecs_warn(__FILE__, __LINE__, __VA_ARGS__)

#define ecs_err(...)\
    _ecs_err(__FILE__, __LINE__, __VA_ARGS__)


/* If in debug mode and no tracing verbosity is defined, compile all tracing */
#if !defined(NDEBUG) && !(defined(ECS_TRACE_0) || defined(ECS_TRACE_1) || defined(ECS_TRACE_2) || defined(ECS_TRACE_3))
#define ECS_TRACE_3
#endif

#ifndef NDEBUG
#if defined(ECS_TRACE_3)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...) ecs_trace(3, __VA_ARGS__);

#elif defined(ECS_TRACE_2)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...)

#elif defined(ECS_TRACE_1)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#else
#define ecs_trace_1(...)
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#endif

////////////////////////////////////////////////////////////////////////////////
//// Exceptions
////////////////////////////////////////////////////////////////////////////////

/** Get description for error code */
FLECS_API const char* ecs_strerror(
    int32_t error_code);

/** Abort */
FLECS_API void _ecs_abort(
    int32_t error_code,
    const char *file,
    int32_t line);

#define ecs_abort(error_code)\
    _ecs_abort(error_code, __FILE__, __LINE__); abort()

/** Assert */
FLECS_API void _ecs_assert(
    bool condition,
    int32_t error_code,
    const char *condition_str,
    const char *file,
    int32_t line);

#ifdef NDEBUG
#define ecs_assert(condition, error_code)
#else
#define ecs_assert(condition, error_code)\
    _ecs_assert(condition, error_code, #condition, __FILE__, __LINE__);\
    assert(condition)
#endif

#ifdef __cplusplus
}
#endif

#endif
/**
 * @file type.h
 * @brief Type API.
 */

#ifndef FLECS_TYPE_H
#define FLECS_TYPE_H

typedef const ecs_vector_t* ecs_type_t;

#ifdef __cplusplus
extern "C" {
#endif

FLECS_API char* ecs_type_str(
    ecs_world_t *world,
    ecs_type_t type);    

FLECS_API bool ecs_type_has_entity(
    const ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_API int32_t ecs_type_index_of(
    ecs_type_t type,
    ecs_entity_t component);

FLECS_API ecs_entity_t ecs_type_contains(
    ecs_world_t *world,
    ecs_type_t type_id_1,
    ecs_type_t type_id_2,
    bool match_all);

#ifdef __cplusplus
}
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct EcsName {
    const char *value;
    const char *symbol;
    char *alloc_value;
} EcsName;

typedef struct EcsType {
    ecs_size_t size;
} EcsType;

typedef struct ecs_lifecycle_t {
    ecs_xtor_t ctor;
    ecs_xtor_t dtor;
    ecs_copy_t copy;
    ecs_move_t move;
    bool is_set;
} ecs_lifecycle_t;

typedef struct ecs_store_policy_t {
    int8_t partition;
    bool sparse;
} ecs_store_policy_t;


/**
 * @defgroup world_api World API
 * @{
 */

FLECS_API ecs_world_t* ecs_init(void);

FLECS_API int ecs_fini(
    ecs_world_t *world);

FLECS_API void ecs_set_lifecycle(
    ecs_world_t *world,
    ecs_entity_t id,
    ecs_lifecycle_t *actions);

FLECS_API void ecs_set_storage(
    ecs_world_t *world,
    ecs_entity_t id,
    ecs_store_policy_t policy,
    bool is_hint);

FLECS_API const EcsType* ecs_get_type_from_id(
    ecs_world_t *world,
    ecs_entity_t id);

FLECS_API ecs_entity_t ecs_get_type_id_from_id(
    ecs_world_t *world,
    ecs_entity_t id);

FLECS_API void ecs_dim(
    ecs_world_t *world,
    int32_t entity_count);

FLECS_API void ecs_defer_begin(
    ecs_world_t *world);

FLECS_API void ecs_defer_end(
    ecs_world_t *world);

FLECS_API void ecs_tracing_enable(
    int level);

FLECS_API int32_t ecs_get_thread_index(
    ecs_world_t *world);    

/** @} */


/**
 * @defgroup basic Basic ECS operations
 * @{
 */

FLECS_API ecs_entity_t ecs_new_id(
    ecs_world_t *world);

FLECS_API ecs_entity_t ecs_new_component_id(
    ecs_world_t *world);

FLECS_API void ecs_add_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void ecs_remove_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void ecs_clear(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API const void* ecs_get_id(
    const ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void* ecs_get_mut_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void ecs_modified_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API ecs_entity_t ecs_set_ptr_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id,
    const void *ptr,
    size_t size);

FLECS_API bool ecs_has_id(
    const ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API bool ecs_is_alive(
    const ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API bool ecs_exists(
    const ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API ecs_type_t ecs_get_type(
    const ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API const char* ecs_get_name(
    const ecs_world_t *world,
    ecs_entity_t entity);

/** @} */


/**
 * @defgroup scopes Scoping
 * @{
 */

FLECS_API ecs_entity_t ecs_set_scope(
    ecs_world_t *world,
    ecs_entity_t scope);

FLECS_API ecs_entity_t ecs_get_scope(
    const ecs_world_t *world);

/** @} */


/**
 * @defgroup macro_api Macro wrappers for type safety & convenience
 * @{
 */

#define ecs_pair(role, subject) (ECS_PAIR | ((uint64_t)role << 32) | (uint32_t)subject)

#define ecs_get_role(id) ((id & ~ECS_FLAGS) >> 32)

#define ecs_get_subject(id) ((uint32_t)id)

#define ecs_has_role(role, id) (ecs_get_role(id) == role)

#define ecs_has_flag(id, flag) ((id & flag) == flag) 

#define ecs_typeid(T) FLECS__E##T


#ifndef FLECS_LEGACY

#define ecs_has(world, entity, type)\
    (ecs_has_id(world, entity, ecs_typeid(type)))

#define ecs_get(world, entity, type)\
    ((const type*)ecs_get_id(world, entity, ecs_typeid(type)))

#define ecs_get_mut(world, entity, type, is_added)\
    ((type*)ecs_get_mut_id(world, entity, ecs_typeid(type), is_added))

#define ecs_set(world, entity, type, ...)\
    (ecs_set_ptr_id(world, entity, ecs_typeid(type), &(type)__VA_ARGS__, sizeof(type)))

#endif

/** @} */ 


#ifdef __cplusplus
}
#endif

#endif
